import { z } from 'zod';
export const ActionCandidateSchema = z.object({
    isActionable: z.boolean(),
    reasons: z.array(z.string()).default([]),
});
function hasAutoGeneratedHeaders(headers) {
    if (!headers)
        return false;
    const autoSub = headers['List-Unsubscribe'] || headers['list-unsubscribe'];
    const bulk = headers['Precedence'] || headers['precedence'];
    const autoSubmitted = headers['Auto-Submitted'] || headers['auto-submitted'];
    const xAuto = headers['X-Auto-Response-Suppress'] || headers['x-auto-response-suppress'];
    return Boolean(autoSub || bulk === 'bulk' || autoSubmitted || xAuto);
}
const ACTION_PATTERNS = [
    /\bcan you\b/i,
    /\bcould you\b/i,
    /\bplease\b/i,
    /\bdue\b/i,
    /\bby\s+\w+/i,
    /\bschedule\b/i,
    /\bset up\b/i,
    /\bfollow up\b/i,
    /\bETA\b/i,
    /\bASAP\b/i,
    /\btomorrow|today|next week|monday|tuesday|wednesday|thursday|friday\b/i,
    /\b\d{1,2}\/(\d{1,2})\/(\d{2,4})/,
];
export function evaluateMessageForAction(message) {
    const reasons = [];
    const text = `${message.subject ?? ''}\n${message.text ?? ''}`.trim();
    const headers = message.headers;
    if (hasAutoGeneratedHeaders(headers)) {
        return { isActionable: false, reasons: ['auto_generated_headers'] };
    }
    let matched = false;
    for (const pattern of ACTION_PATTERNS) {
        if (pattern.test(text)) {
            matched = true;
            reasons.push(`matched:${pattern.toString()}`);
        }
    }
    return { isActionable: matched, reasons };
}
//# sourceMappingURL=rules.js.map